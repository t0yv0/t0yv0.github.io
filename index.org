* Torn slices in Go that defy intuition
<2024-11-03 Sun>

There is a very strange Go slice that identifies with ~nil~ and yet has a non-zero length. This slice made an appearance
in a prod system and really made everybody's day.

#+begin_src go
  var xs []int

  if len(xs) == 1 && xs == nil {
	panic("This is impossible, right?")
  }
#+end_src

[[https://github.com/pulumi/pulumi/issues/11727#issuecomment-1373883493][Reference]] ticket.

What is happening under the hood?

A Go slice is a struct-like structure, somewhat like this:

#+begin_src go
  type s struct {
        array *ptr
        offset int
        length int
  }
#+end_src

Now, ~xs == nil~ should not have been possible for a struct-like structure but is so common it must have been included
for convenience. What it actually desugars to is ~xs.array == nil~.

When memory is shared across goroutines in a data race, one goroutine can modify the array pointer and make it nil. At
the same time the length data remains non-zero to the confusion of another goroutine.

Clojure is having an I-told-you-so moment. Concurrency and mutable state do not mix well together.

* git-spice
<2024-11-02 Sat>

[[https://abhinav.github.io/git-spice/][git-spice]] is really well made, as you would expect from [[https://github.com/abhinav][abhinav]]. I had a pleasure of trying this out at work this week.

What problem does this tool solve?

Suppose you are on a distributed remote-first software team. Things are going great, you have colleagues from Europe,
U.S. and Australia, and you have the benefit of diverse perspectives. But then things succeed. Things get a little busy.
Pull requests start piling up in the review pile.

How do you proceed with your software work? If you need to make a lot of changes, some of them inter-dependent. Waiting
for each change to be reviewed is harder if your reviewers are in a different time zone. Submitting a very large pull
request makes it harder on your reviewers.

Here is where stacked pull requests are really handy. Work at your own pace, submit small dependent increments in bulk
for review. However, once you start receiving feedback, you are in for rebase work.

Here is where git-spice really shines.

~gs stack restack~ and all your branches are rebased.

~gs stack submit~ and all your pull requests are up-to-date with your changes.

Amazing!

Is it a keeper? Possibly. There is one remaining challenge, some GitHub repositories I am working with are setup to
squash merge. They also tend to have very long-running CI times and GitHub merge queues are likely coming. This is a
known documented limitation:

https://abhinav.github.io/git-spice/guide/limits/#squash-merges-restack-the-upstack

Looks like some further work could be done to enable the ideal workflow: once all the pull requests are approved, submit
them all to the merge queue and never worry about them again unless CI finds issues.


-----

file:about.org
